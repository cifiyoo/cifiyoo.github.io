---
layout: post
title: '小朋友排队'
date: 2019-01-29
categories: ACM
tags: 树状数组 逆序对
---
## 题目
n 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。
每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是0。
如果某个小朋友第一次被要求交换，则他的不高兴程度增加1，如果第二次要求他交换，则他的不高兴程度增加2（即不高兴程度为3），依次类推。当要求某个小朋友第k次交换时，他的不高兴程度增加k。
请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。
如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。
【数据格式】
输入的第一行包含一个整数n，表示小朋友的个数。
第二行包含 n 个整数$H1 H2 … Hn$，分别表示每个小朋友的身高。
输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。
例如，输入：
3
3 2 1
程序应该输出：
9
【样例说明】
首先交换身高为3和2的小朋友，再交换身高为3和1的小朋友，再交换身高为2和1的小朋友，每个小朋友的不高兴程度都是3，总和为9。
【数据规模与约定】
对于10%的数据， $1<=n<=10$；
对于30%的数据， $1<=n<=1000$；
对于50%的数据， $1<=n<=10000$；
对于100%的数据，$1<=n<=100000，0<=Hi<=1000000$。
## 思路
对于一个小朋友来说，他的不高兴程度为左边身高比他高的人的个数与右边比他矮的人数的和，即就是一个逆序对的求取，求取逆序对有两种方式，归并以及树状数组，本题涉及到的主要知识点就是树状数组的应用。$c[i] = c[i-2^k+1]+...+c[i]$.k为二进制数末尾0的个数，2^k可以用$i&(-i)$求得。
## 代码
```clike
#include<bits/stdc++.h>
#define maxn 100005
#define MAXN 1000005
using namespace std;

int c[MAXN],  a[MAXN];
long long b[maxn];
int n;
//获取最小比特
int lowbit(int x)
{
    return x & (-x);
}
//获取前x项和
int getSum(int x)
{
    int s = 0;
    for(int i = x; i; i -= lowbit(i))
        s += c[i];
    return s;
}
//修改更新
void add(int x, int val)
{
    for(int i = x; i < MAXN; i += lowbit(i))
    {
        c[i] += val;
    }
}
int main()
{
    scanf("%d", &n);
    //左边逆序对
    memset(c, 0, sizeof(c));
    for(int i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
        add(a[i] + 1, 1);
        b[i] = (i + 1) - getSum(a[i] + 1);

    }
    //右边逆序对
    memset(c, 0, sizeof(c));
    for(int i = n - 1; i >= 0; i--)
    {
        add(a[i] + 1, 1);
        b[i] += getSum(a[i]);
    }
    long long ans = 0;
    for(int i = 0; i < n; i++)
    {
        ans += (1 + b[i]) * b[i] / 2;
    }
    printf("%lld\n", ans);
}

```