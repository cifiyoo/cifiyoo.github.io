---

layout: post
title: '解码方法II'
date: 2021-09-27
categories: ACM
tags: DP leetcode

---

## 解码方法II

一条包含字母 A-Z 的消息通过以下的方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，`"11106"` 可以映射为：

`"AAJF"` 对应分组 `(1 1 10 6)`
`"KJF"` 对应分组 `(11 10 6)`
注意，像 `(1 11 06)` 这样的分组是无效的，因为 `"06"` 不可以映射为 `'F'` ，因为 `"6" `与` "06"` 不同。

除了 上面描述的数字字母映射方案，编码消息中可能包含` '*'` 字符，可以表示从` '1' `到 `'9' `的任一数字（不包括` '0'`）。例如，编码字符串 `"1*" `可以表示 `"11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19"` 中的任意一条消息。对`"1*" `进行解码，相当于解码该字符串可以表示的任何编码消息。

给你一个字符串` s `，由数字和 `'*' `字符组成，返回 解码 该字符串的方法 数目 。

由于答案数目可能非常大，返回对` 10^9 + 7` 取余 的结果。
链接：https://leetcode-cn.com/problems/decode-ways-ii


## 样例

```
输入：s = "2*"
输出：15
解释：这一条编码消息可以表示 "21"、"22"、"23"、"24"、"25"、"26"、"27"、"28" 或 "29" 中的任意一条。
"21"、"22"、"23"、"24"、"25" 和 "26" 由 2 种解码方法，但 "27"、"28" 和 "29" 仅有 1 种解码方法。
因此，"2*" 共有 (6 * 2) + (3 * 1) = 12 + 3 = 15 种解码方法。
```



## 题解

```C++
class Solution {
public:
//dp[i] = dp[i-1] * i + dp[i-2] * (i-1&i)
    int numDecodings(string s) {
        long long dp[100005];
        memset(dp,0,sizeof(dp));
        int len = s.length();
        if(len == 0 )return 0;
        if(s[0] == '0') return 0;
        if(s[0] == '*' && len == 1) return 9;
        if(len == 1) return 1;
        dp[0] = 1;
        dp[1] = s[0] == '*'?9:1;
        for(int i = 2;i <= len;i++){
           if(s[i-1] == '*') dp[i]+=9*dp[i-1];
           else if(s[i-1]> '0')dp[i] += dp[i-1];//种数不变

           if(s[i-2] == '*'){
               if(s[i-1] == '*') dp[i] += 15*dp[i-2];
               else if(s[i-1] <= '6')dp[i] += 2*dp[i-2];
               else dp[i] += dp[i-2];
           }
           else if(s[i-2] == '1'||s[i-2] == '2'){
                if(s[i-1] == '*') dp[i] += s[i-2] == '1'?9 * dp[i-2]:6 * dp[i-2];
                else if((s[i-2]-'0')*10 + s[i-1]-'0' <= 26)dp[i] += dp[i-2];
           }
           dp[i] %= 1000000007;
        }
        return dp[len];
    }
};
```

`dp[i]`表示`[0……i]`的解码种类数，递推公式： ` dp[i] = dp[i - 1] * [第i个单独解码的个数] + dp[i - 2] * [第i-1 和第i一起解码的个数]`